#lang racket

(require "helpers.rkt")
(require "mcons-all-the-things.rkt")
(require "section-3-3-4-book.rkt")

;;; Exercise 3.28

(println "exercise 3.28")

(define (logical-or s1 s2)
  (if (or (= s1 1) (= s2 1)) 1 0))

(define (or-gate input-1 input-2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal input-1) (get-signal input-2))))
      (after-delay or-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input-1 or-action-procedure)
  (add-action! input-2 or-action-procedure)
  'ok)

;; Test an or-gate

(reset-agenda!)
(define input-1 (make-wire))
(define input-2 (make-wire))
(define output (make-wire))
(or-gate input-1 input-2 output)
(probe 'output output)
(log-with-time "created wires and or-gate")
(set-signal! input-1 1)
(log-with-time "raised input-1")
(propagate)
(set-signal! input-2 1)
(log-with-time "raised input-2")
(propagate)
(set-signal! input-1 0)
(log-with-time "lowered input-1")
(propagate)
(set-signal! input-2 0)
(log-with-time "lowered input-2")
(propagate)

;;; Exercise 3.29

(println "exercise 3.29")

(define (nand-or-gate input-1 input-2 output)
  (define not-input-1 (make-wire))
  (define not-input-2 (make-wire))
  (define not-output (make-wire))
  (inverter input-1 not-input-1)
  (inverter input-2 not-input-2)
  (and-gate not-input-1 not-input-2 not-output)
  (inverter not-output output))

(reset-agenda!)
(define input-3 (make-wire))
(define input-4 (make-wire))
(define output-2 (make-wire))
(nand-or-gate input-3 input-4 output-2)
(propagate)
(probe 'output-2 output-2)
(log-with-time "created wires and nand-or-gate")
(set-signal! input-3 1)
(log-with-time "raised input-3")
(propagate)
(set-signal! input-4 1)
(log-with-time "raised input-4")
(propagate)
(set-signal! input-3 0)
(log-with-time "lowered input-3")
(propagate)
(set-signal! input-4 0)
(log-with-time "lowered input-4")
(propagate)

;; The delay of the nand-gate based or-gate is 7, (+ (* 2 inverter-delay) and-gate-delay). That makes sense, as the pipeline length from input to output includes two inverters and one and-gate.

;;; Exercise 3.30

;; Now we need the half and full adders from the text:

(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))

(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))

;;; Example use
(println "half-adder test")
(reset-agenda!)
(define input-5 (make-wire))
(define input-6 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
(probe 'sum sum)
(probe 'carry carry)

(half-adder input-5 input-6 sum carry)
(log-with-time "constructed half-adder")
(propagate)
(set-signal! input-5 1)
(log-with-time "raised input-5")
(propagate)

(set-signal! input-6 1)
(log-with-time "raised input-6")
(propagate)

(define (make-bus width)
  (list->mlist (map (lambda (x) (make-wire)) (range width))))
(define (ripple-carry-adder a-bits b-bits sum-bits carry)
  (define carry-bits (make-bus (length a-bits)))
  (define (next-bit a-bits b-bits sum-bits carry-bus carry-out)
    (if (null? a-bits)
        'ok
        (begin
          (full-adder (car a-bits)
                      (car b-bits)
                      (car carry-bus)
                      (car sum-bits)
                      carry-out)
          (next-bit (cdr a-bits) 
                    (cdr b-bits)
                    (cdr sum-bits)
                    (cdr carry-bus)
                    (car carry-bus)
                    ))))
  (next-bit a-bits b-bits sum-bits carry-bits carry))
  
(define (probe-bus name bus)
  (define name-string (symbol->string name))
  (define bus-as-list (mlist->list bus))
  (define (log-bus)
    (log-with-time name-string)
    (display "    ")
    (map (lambda (w) (display (get-signal w))) bus-as-list)
    (newline))
  (map (lambda (w) (add-action! w log-bus)) bus-as-list))
(define (set-bus! bus values)
  (if (null? bus)
      'ok
      (begin
        (set-signal! (car bus) (car values))
        (set-bus! (cdr bus) (cdr values)))))

(println "exercise 3.30")
(define adder-width 2)

(reset-agenda!)
(define a-bus (make-bus adder-width))
(define b-bus (make-bus adder-width))
(define s-bus (make-bus adder-width))
(define c (make-wire))
(probe-bus 'sum s-bus)
(probe 'carry c)
(ripple-carry-adder a-bus b-bus s-bus c)
(log-with-time "constructed ripple carry adder")
(propagate)
(set-bus! a-bus (mlist 0 1))
(log-with-time "set a-bus to 01")
(propagate)
(set-bus! b-bus (mlist 1 0))
(log-with-time "set b-bus to 10")
(propagate)
(set-bus! b-bus (mlist 1 1))
(log-with-time "set b-bus to 11")
(propagate)
(set-bus! a-bus (mlist 1 1))
(log-with-time "set a-bus to 11")
(propagate)
(set-bus! a-bus (mlist 0 0))
(log-with-time "set a-bus to 00")
(propagate)

(println "delay test")
(define (repeat val count)
  (if (= count 0)
      '()
      (cons val (repeat val (- count 1)))))
(define (test-rca-delay max-width)
  (define (helper width)
    (if (= width (+ max-width 1))
        'done
        (let ((a-bus (make-bus width))
              (b-bus (make-bus width))
              (s-bus (make-bus width))
              (c (make-wire)))
          (reset-agenda!)
          (probe-bus 'sum s-bus)
          (probe 'carry c)
          (ripple-carry-adder a-bus b-bus s-bus c)
          (log-with-time "constructed ripple carry adder")
          (propagate)
          (set-bus! a-bus (repeat 1 width))
          (log-with-time "set a-bus to all high")
          (propagate)
          (set-bus! b-bus (cons 0 (repeat 1 (- width 1))))
          (log-with-time "set b-bus to 011…")
          (propagate)
          (log-with-time "adder stablized")
          (println "------------")
          (helper (+ width 1)))))
  (helper 1))
(test-rca-delay 10)

          
                    
